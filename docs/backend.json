{
  "entities": {
    "SongRequest": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SongRequest",
      "type": "object",
      "description": "Represents a song request submitted by a patron.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the song request."
        },
        "songTitle": {
          "type": "string",
          "description": "Title of the requested song."
        },
        "artistName": {
          "type": "string",
          "description": "Name of the artist for the requested song."
        },
        "specialAnnouncement": {
          "type": "string",
          "description": "Optional special announcement for the song request."
        },
        "requestTime": {
          "type": "string",
          "description": "Timestamp indicating when the song request was submitted.",
          "format": "date-time"
        },
        "patronId": {
          "type": "string",
          "description": "Reference to Patron. (Relationship: Patron 1:N SongRequest)"
        },
        "status": {
          "type": "string",
          "description": "The status of the song request such as 'pending', 'playing', 'finished', or 'removed'."
        }
      },
      "required": [
        "id",
        "songTitle",
        "artistName",
        "requestTime",
        "patronId",
        "status"
      ]
    },
    "Patron": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Patron",
      "type": "object",
      "description": "Represents a patron or singer using the karaoke app.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the patron."
        },
        "displayName": {
          "type": "string",
          "description": "The display name of the patron."
        }
      },
      "required": [
        "id",
        "displayName"
      ]
    },
    "Tip": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tip",
      "type": "object",
      "description": "Represents a tip given by a patron to the KJ or band.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the tip."
        },
        "amount": {
          "type": "number",
          "description": "The amount of the tip."
        },
        "tipTime": {
          "type": "string",
          "description": "Timestamp indicating when the tip was given.",
          "format": "date-time"
        },
        "patronId": {
          "type": "string",
          "description": "Reference to Patron. (Relationship: Patron 1:N Tip)"
        }
      },
      "required": [
        "id",
        "amount",
        "tipTime",
        "patronId"
      ]
    },
    "KaraokeJockey": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "KaraokeJockey",
      "type": "object",
      "description": "Represents a karaoke jockey or admin user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the karaoke jockey."
        },
        "displayName": {
          "type": "string",
          "description": "The display name of the karaoke jockey."
        }
      },
      "required": [
        "id",
        "displayName"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/patrons/{patronId}",
        "definition": {
          "entityName": "Patron",
          "schema": {
            "$ref": "#/backend/entities/Patron"
          },
          "description": "Stores patron profiles.  `patronId` is equal to `request.auth.uid`.",
          "params": [
            {
              "name": "patronId",
              "description": "The unique identifier for the patron. Must match the authenticated user's UID."
            }
          ]
        }
      },
      {
        "path": "/patrons/{patronId}/song_requests/{songRequestId}",
        "definition": {
          "entityName": "SongRequest",
          "schema": {
            "$ref": "#/backend/entities/SongRequest"
          },
          "description": "Stores song requests submitted by patrons. `patronId` matches the patron document id; `songRequestId` is a unique identifier for the song request.",
          "params": [
            {
              "name": "patronId",
              "description": "The unique identifier for the patron who submitted the request. Must match the authenticated user's UID."
            },
            {
              "name": "songRequestId",
              "description": "The unique identifier for the song request."
            }
          ]
        }
      },
      {
        "path": "/patrons/{patronId}/tips/{tipId}",
        "definition": {
          "entityName": "Tip",
          "schema": {
            "$ref": "#/backend/entities/Tip"
          },
          "description": "Stores tips given by patrons. `patronId` matches the patron document id; `tipId` is a unique identifier for the tip.",
          "params": [
            {
              "name": "patronId",
              "description": "The unique identifier for the patron who gave the tip. Must match the authenticated user's UID."
            },
            {
              "name": "tipId",
              "description": "The unique identifier for the tip."
            }
          ]
        }
      },
      {
        "path": "/karaoke_jockeys/{karaokeJockeyId}",
        "definition": {
          "entityName": "KaraokeJockey",
          "schema": {
            "$ref": "#/backend/entities/KaraokeJockey"
          },
          "description": "Stores karaoke jockey profiles. `karaokeJockeyId` is the document ID.",
          "params": [
            {
              "name": "karaokeJockeyId",
              "description": "The unique identifier for the karaoke jockey."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to support a karaoke queue management application with real-time updates and role-based access control. It uses a combination of path-based ownership for patrons' data and a global collection for Karaoke Jockeys. The structure prioritizes authorization independence by denormalizing data where needed and ensures secure list operations (QAPs) via structural segregation.  Specifically, the song requests are stored as subcollections of patron documents enabling secure reads and writes based on the patron's ID. Tips are also stored as subcollections of patrons. The karaoke jockeys are stored in a root collection which allows for simple role-based access control. This design eliminates the need for complex `get()` calls in security rules, enabling atomic operations and improving debuggability. Denormalizing the `members` map is not applicable here, as there are not collaborative entities modeled."
  }
}